# GLSL Shader Development Guidelines

## Critical: Prevent Common GLSL Errors

### 1. Vector Constructor Rules

GLSL constructors require **exact component counts**. Mismatches cause silent failures that cascade into "undeclared identifier" errors.

```glsl
// ❌ WRONG — 4 components into vec3
vec3 b0 = vec3(x.xy, y.xy);  // vec2 + vec2 = 4 floats

// ✅ CORRECT — 3 components into vec3
vec3 b0 = vec3(x.xy, y.z);   // vec2 + float = 3 floats

// ✅ CORRECT — 4 components into vec4
vec4 b0 = vec4(x.xy, y.xy);  // vec2 + vec2 = 4 floats
```

### 2. Matrix Multiplication Rules

GLSL matrix multiplication is **order-dependent**. The matrix must be on the LEFT.

```glsl
// ❌ WRONG — vec * mat is invalid
vec2 s = vec2(x.x, x.y) * m;  // ERROR: '*' does not operate on 'vec2' and 'mat2'

// ✅ CORRECT — mat * vec is valid
vec2 s = m * vec2(x.x, x.y);  // mat2 * vec2 → vec2
```

| Operation | Result | Valid? |
|-----------|--------|--------|
| `mat2 * vec2` | vec2 | ✅ Yes |
| `mat3 * vec3` | vec3 | ✅ Yes |
| `mat4 * vec4` | vec4 | ✅ Yes |
| `vec2 * mat2` | — | ❌ No |
| `vec3 * mat3` | — | ❌ No |
| `vec4 * mat4` | — | ❌ No |

**Safer alternative:** Use dot products instead of matrix multiplication for hash functions:

```glsl
// ✅ RECOMMENDED — avoids matrix entirely
vec2 hash2_3(in vec3 x) {
    return fract(sin(vec2(
        dot(x, vec3(20.5283, 24.1994, 70.2913)),
        dot(x, vec3(89.9132, 57.1454, 45.1211))
    )) * 492.194);
}
```

### 3. Missing Function Definitions

Every function call must have a corresponding definition. "Undeclared identifier" errors for function names mean the function is missing.

```
ERROR: 0:28: Invalid call of undeclared identifier 'random3'
```

**Common causes:**
- Incomplete copy-paste from reference code
- Missing utility/helper functions
- Typo in function name

**Before using any function, verify:**
1. The function is defined above the call site
2. The function name matches exactly (case-sensitive)
3. The parameter types match the definition

**Standard hash/random functions to include:**

```glsl
// 1D hash from 2D input
float hash1_2(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// 2D hash from 3D input
vec2 hash2_3(vec3 p) {
    return fract(sin(vec2(
        dot(p, vec3(20.5283, 24.1994, 70.2913)),
        dot(p, vec3(89.9132, 57.1454, 45.1211))
    )) * 492.194);
}

// 3D hash from 3D input
vec3 hash3_3(vec3 p) {
    return fract(sin(vec3(
        dot(p, vec3(127.1, 311.7, 74.7)),
        dot(p, vec3(269.5, 183.3, 246.1)),
        dot(p, vec3(113.5, 271.9, 124.6))
    )) * 43758.5453);
}
```

### 4. Component Count Reference

| Type | Components | Valid Constructors |
|------|------------|-------------------|
| `vec2` | 2 | `vec2(float, float)` or `vec2(vec2)` |
| `vec3` | 3 | `vec3(f, f, f)` or `vec3(vec2, f)` or `vec3(f, vec2)` |
| `vec4` | 4 | `vec4(vec2, vec2)` or `vec4(vec3, f)` or `vec4(f, vec3)` |

---

## Pre-Compile Checklist

Before compiling any shader:

- [ ] **Count constructor components** — every `vec2/vec3/vec4` has exact count
- [ ] **Check matrix multiplication order** — matrix on LEFT (`mat * vec`)
- [ ] **Verify all functions exist** — every called function is defined above call site
- [ ] **Check for duplicate code** — no accidental double-paste of sections
- [ ] **Verify `#version` is first line** — nothing before it, not duplicated

---

## Debugging Cascading Errors

When you see multiple errors like:
```
ERROR: 0:78: Incompatible types in initialization
ERROR: 0:79: Use of undeclared identifier 'm'
ERROR: 0:80: Use of undeclared identifier 'm'
```

**The root cause is always the FIRST error.** Fix line 78; the rest will resolve.

**Error cascade pattern:**
1. Line N has type error → variable fails to declare
2. Lines N+1, N+2... reference the undeclared variable
3. Fixing line N fixes everything

---

## Safe Noise Pattern (Recommended Starter)

```glsl
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}
```

---

## Before Using Copied Shader Code

1. **Verify it compiles** — Test the code in isolation before integrating
2. **Trace to original source** — Find the authoritative version (e.g., Ashima GitHub for simplex noise)
3. **Check all constructors** — Count components in every `vec2/vec3/vec4/mat` constructor
4. **Check matrix operations** — Ensure matrix is always on the LEFT side of multiplication
5. **List all function calls** — Verify each one has a definition
6. **Prefer simple patterns** — Dot-product hash functions are safer than matrix-based ones

---

## Trusted Noise Sources

- Hash-based: Shadertoy reference patterns
- Simplex: github.com/ashima/webgl-noise (use unmodified)
- Collection: github.com/patriciogonzalezvivo/lygia

---

## Common Error Summary

| Error Message | Cause | Fix |
|---------------|-------|-----|
| `Incompatible types in initialization` | Wrong component count in constructor | Count components, match to vec type |
| `'*' does not operate on 'vecN' and 'matN'` | Wrong multiplication order | Put matrix on LEFT: `mat * vec` |
| `Invalid call of undeclared identifier 'X'` | Function X not defined | Add function definition above call |
| `Use of undeclared identifier 'X'` | Variable X not declared (often cascading) | Fix the FIRST error in the list |