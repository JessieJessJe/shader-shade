Shadertoy Reference Document

Particle Flow System

Source: shadertoy.com/view/ttB3Rt | Author: Jan Mróz (jaszunio15) | License: CC BY 3.0

Reference Overview
A 2D particle system where thousands of soft dots flow organically across the screen, driven by 3D noise. Includes multi-pass blur for glow effect. Key value: demonstrates grid-based particle placement with noise-driven movement.



1. Shader Architecture

This shader uses a multi-buffer architecture for progressive rendering:



2. Core Techniques


2.1 Hash Functions (Pseudo-random)

Fast, deterministic random number generation from coordinates. Essential for procedural content.

TECHNIQUE: 1D Hash from 2D Input

Returns a single random value [0,1] from a 2D coordinate. Used for particle size variation.

float hash1_2(in vec2 x) {

    return fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);

}

TECHNIQUE: 2D Hash from 3D Input

Returns 2D random values from 3D coordinate. Used for particle displacement.

vec2 hash2_3(in vec3 x) {

    return fract(sin(x * mat2x3(20.5283, 24.1994, 70.2913,

                                89.9132, 57.1454, 45.1211)) * 492.194);

}



2.2 Interpolated Noise

Smooth noise by interpolating between random values at grid points. Creates organic, continuous variation.

TECHNIQUE: 3D Noise returning 2D values

Trilinear interpolation of hash values. The Z dimension allows animation over time.

vec2 noise2_3(vec3 coord) {

    vec3 f = smoothstep(0.0, 1.0, fract(coord));

    vec3 uv000 = floor(coord);

    // ... sample 8 corners of the cube ...

    // ... trilinear interpolation ...

    return v;

}



2.3 Grid-Based Particle System

The core innovation: divide UV space into cells, place one particle per cell, let it move within/across cells.

TECHNIQUE: Cell Division

Floor operation divides continuous UV into discrete cells. Each cell owns one particle.

vec2 rootUV = floor(uv);

// rootUV identifies which cell we&apos;re in

// Each cell will contribute one particle

TECHNIQUE: Particle Movement

Noise displaces each particle from its cell center. Creates organic flow.

vec2 cellPointFromRootUV(vec2 rootUV, vec2 originalUV, out float len) {

    vec2 displacement = noise2_3(vec3(

        rootUV * 0.07 + iTime * 0.3,

        0.5 * (iTime + 0.1) + noise1_2(originalUV * 0.04)

    )) - 0.5;

    len = dot(displacement, displacement);

    return displacement * 3.0 * PARTICLE_ITERATIONS + 0.5 + rootUV;

}

TECHNIQUE: Neighbor Iteration

Check surrounding cells — particles can move across cell boundaries.

for (float x = -PARTICLE_ITERATIONS; x <= PARTICLE_ITERATIONS; x += 1.0) {

    for (float y = -PARTICLE_ITERATIONS; y <= PARTICLE_ITERATIONS; y += 1.0) {

        tempRootUV = rootUV + vec2(x, y);

        pointUV = cellPointFromRootUV(tempRootUV, uv, dist);

        particles += particleFromUVAndPoint(uv, pointUV, ...);

    }

}



2.4 Soft Particle Rendering

Each particle is a soft dot with smooth falloff, not a hard circle.

TECHNIQUE: Distance-based Falloff

Smoothstep creates soft edges. Squaring the result sharpens the core.

float particleFromUVAndPoint(vec2 uv, vec2 point, ...) {

    float dist = distance(uv, point);

    float particle = 1.0 - smoothstep(

        PARTICLE_RADIUS - dist * 0.05,

        PARTICLE_RADIUS2 - dist * 0.05 + pixelSize,

        dist

    );

    return particle * particle;  // Sharpen

}




4. Adaptation Notes


4.1 What This Reference Provides


Grid-based particle placement system


Noise-driven organic movement


Soft particle rendering with smooth falloff


Hash functions for deterministic randomness


Multi-pass blur for glow effects



4.2 What This Reference Does NOT Provide


3D surface/geometry — this is a flat 2D field


Edge/silhouette detection — no surface normals


Depth variation — all particles at same &quot;depth&quot;


View-dependent effects — no camera/perspective



4.3 Techniques to Borrow


The particle rendering approach (soft dots with smoothstep)


The grid + iteration pattern for distributing many particles


Noise functions for organic variation


The brightness/color mixing approach



4.4 Techniques to Add for 3D Surfaces


Parametric surface function (e.g., sin waves for ribbon shape)


Surface normal calculation (for edge highlighting)


UV mapping particles onto the 3D surface


Fresnel or normal-based brightness (edges glow brighter)



